<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Global Location Extractor with Overpass POST Fallback</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"
/>
<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"
/>
<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"
/>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 0;
  }
  #map {
    height: 65vh;
    width: 100%;
  }
  #controls {
    padding: 15px;
    background: #f4f4f4;
  }
  #results {
    padding: 10px;
    height: 35vh;
    overflow-y: scroll;
    background: #fff;
    border-top: 1px solid #ccc;
  }
  input,
  select,
  button {
    margin-right: 10px;
    margin-bottom: 5px;
    padding: 8px;
  }
  select {
    min-width: 150px;
  }
  .loading {
    opacity: 0.6;
    pointer-events: none;
  }
  .control-row {
    margin-bottom: 10px;
  }
  label {
    display: inline-block;
    min-width: 80px;
    font-weight: bold;
  }
</style>
</head>
<body>
<div id="controls">
  <div class="control-row">
    <label for="location">Location:</label>
    <input
      type="text"
      id="location"
      placeholder="e.g. London, England, United Kingdom"
      list="location-suggestions"
    />
    <datalist id="location-suggestions">
      <option value="London"></option>
      <option value="Manchester"></option>
      <option value="Birmingham"></option>
      <option value="Glasgow"></option>
      <option value="Liverpool"></option>
      <option value="Edinburgh"></option>
      <option value="Bristol"></option>
      <option value="Leeds"></option>
      <option value="Sheffield"></option>
      <option value="Cardiff"></option>
      <option value="United Kingdom"></option>
      <option value="England"></option>
      <option value="Wales"></option>
      <option value="Scotland"></option>
      <option value="USA"></option>
      <option value="Canada"></option>
      <option value="Germany"></option>
      <option value="France"></option>
    </datalist>
  </div>

  <div class="control-row">
    <label for="category">Category:</label>
    <select id="category" onchange="suggestTags()">
      <option value="education">Education</option>
      <option value="shopping">Shopping & Retail</option>
      <option value="entertainment">Entertainment & Venues</option>
      <option value="accommodation">Hotels & Accommodation</option>
      <option value="culture">Culture & Tourism</option>
      <option value="food">Food & Drink</option>
      <option value="healthcare">Healthcare</option>
      <option value="business">Business & Services</option>
      <option value="welfare">Welfare & Support</option>
      <option value="shops">Specialist Shops</option>
    </select>
  </div>

  <div class="control-row">
    <label for="subcategory">Type:</label>
    <select id="subcategory">
      <option value="">Select a type...</option>
    </select>
  </div>

  <div class="control-row">
    <button onclick="fetchData()" id="searchBtn">Search</button>
    <button onclick="downloadCSV()">Download CSV</button>
    <button onclick="downloadGeoJSON()">Download GeoJSON</button>
  </div>
</div>

<div id="map"></div>
<div id="results"></div>

<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

<script>
  let map = L.map("map").setView([20, 0], 2);

  map.createPane("labels");
  map.getPane("labels").style.zIndex = 650;
  map.getPane("labels").style.pointerEvents = "none";

  const osmLayer = L.tileLayer(
    "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
    {
      attribution: "Map data &copy; OpenStreetMap contributors",
    }
  );

  const esriImagery = L.tileLayer(
    "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
    {
      attribution: "Imagery &copy; Esri",
    }
  );

  const esriLabels = L.tileLayer(
    "https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}",
    {
      attribution: "Labels &copy; Esri",
      pane: "labels",
      interactive: false,
    }
  );

  const satelliteWithLabels = L.layerGroup([esriImagery, esriLabels]);

  const baseLayers = {
    OpenStreetMap: osmLayer,
    "Satellite with Labels (Esri)": satelliteWithLabels,
  };

  osmLayer.addTo(map);
  L.control.layers(baseLayers).addTo(map);

  let markerGroup = L.markerClusterGroup();
  map.addLayer(markerGroup);

  let results = [];
  let geocodeCache = {};

  const categoryOptions = {
    education: {
      Schools: [
        { key: "amenity", value: "school" },
        { key: "amenity", value: "kindergarten" },
      ],
      "Secondary Schools & Sixth Forms": [
        { key: "amenity", value: "school", additional: '"school:type"="secondary"' },
        { key: "amenity", value: "college" },
      ],
      Universities: [{ key: "amenity", value: "university" }],
      Colleges: [{ key: "amenity", value: "college" }],
      Libraries: [{ key: "amenity", value: "library" }],
    },
    shopping: {
      "Shopping Malls": [
        { key: "shop", value: "mall" },
        { key: "amenity", value: "marketplace" },
      ],
      "Business Districts": [{ key: "landuse", value: "commercial" }],
      "Retail Hubs": [
        { key: "shop", value: "supermarket" },
        { key: "amenity", value: "marketplace" },
      ],
      "Gift Shops": [
        { key: "shop", value: "gift" },
        { key: "shop", value: "souvenir" },
      ],
      "Boots Stores": [{ key: "shop", value: "chemist", brand: "Boots" }],
    },
    entertainment: {
      Pubs: [{ key: "amenity", value: "pub" }],
      Bars: [{ key: "amenity", value: "bar" }],
      "Cocktail Bars": [
        { key: "amenity", value: "bar", additional: '"bar"="cocktail"' },
      ],
      "Concert Venues": [
        { key: "amenity", value: "music_venue" },
        { key: "amenity", value: "concert_hall" },
      ],
      Arenas: [
        { key: "leisure", value: "stadium" },
        { key: "amenity", value: "events_venue" },
      ],
      "Amusement Parks": [
        { key: "tourism", value: "theme_park" },
        { key: "leisure", value: "amusement_arcade" },
      ],
    },
    accommodation: {
      Hotels: [{ key: "tourism", value: "hotel" }],
      Resorts: [{ key: "tourism", value: "resort" }],
      "Student Accommodation": [
        { key: "amenity", value: "student_accommodation" },
        { key: "building", value: "dormitory" },
      ],
    },
    culture: {
      Museums: [{ key: "tourism", value: "museum" }],
      Zoos: [
        { key: "tourism", value: "zoo" },
        { key: "tourism", value: "aquarium" },
      ],
      Mosques: [
        { key: "amenity", value: "place_of_worship", additional: '"religion"="muslim"' },
      ],
      Churches: [
        { key: "amenity", value: "place_of_worship", additional: '"religion"="christian"' },
      ],
    },
    food: {
      Cafes: [{ key: "amenity", value: "cafe" }],
      Restaurants: [{ key: "amenity", value: "restaurant" }],
      Bakeries: [{ key: "shop", value: "bakery" }],
    },
    healthcare: {
      Hospitals: [{ key: "amenity", value: "hospital" }],
      Clinics: [
        { key: "amenity", value: "clinic" },
        { key: "amenity", value: "doctors" },
      ],
      Pharmacies: [
        { key: "amenity", value: "pharmacy" },
        { key: "shop", value: "chemist" },
      ],
      "NHS Locations": [
        { key: "amenity", value: "hospital", operator: "NHS" },
        { key: "amenity", value: "clinic", operator: "NHS" },
      ],
    },
    business: {
      "Pharmaceutical Companies": [
        { key: "office", value: "pharmaceutical" },
        { key: "industrial", value: "pharmaceutical" },
      ],
      "Contractors/Building Materials": [
        { key: "shop", value: "trade" },
        { key: "shop", value: "hardware" },
        { key: "shop", value: "doityourself" },
      ],
      "Tools Shops": [
        { key: "shop", value: "hardware" },
        { key: "shop", value: "trade" },
      ],
      "STIHL Stores": [
        { key: "shop", value: "hardware", brand: "STIHL" },
        { key: "shop", value: "garden_centre", brand: "STIHL" },
      ],
    },
    welfare: {
      "Trusts/Human Welfare": [
        { key: "amenity", value: "social_facility" },
        { key: "office", value: "charity" },
      ],
      "Animal Welfare": [
        { key: "amenity", value: "animal_shelter" },
        { key: "office", value: "charity", additional: '"charity"="animal_welfare"' },
      ],
    },
    shops: {
      "Shoe Shops": [{ key: "shop", value: "shoes" }],
      "Smoking Lounges": [
        { key: "amenity", value: "smoking_area" },
        { key: "shop", value: "tobacco" },
      ],
    },
  };

  function suggestTags() {
    const category = document.getElementById("category").value;
    const subcategorySelect = document.getElementById("subcategory");
    subcategorySelect.innerHTML = '<option value="">Select a type...</option>';
    if (categoryOptions[category]) {
      Object.keys(categoryOptions[category]).forEach((subcategory) => {
        const option = document.createElement("option");
        option.value = subcategory;
        option.textContent = subcategory;
        subcategorySelect.appendChild(option);
      });
    }
  }

  // Enhanced geocoding - can handle city/county/country globally
  async function geocodeLocation(location) {
    if (geocodeCache[location]) return geocodeCache[location];
    const url = `https://nominatim.openstreetmap.org/search?format=json&polygon_geojson=1&q=${encodeURIComponent(
      location
    )}`;
    const res = await fetch(url);
    const data = await res.json();
    if (data.length > 0) {
      const best = data[0];
      const bbox = best.boundingbox ? best.boundingbox.map(Number) : null;
      const coords = {
        lat: parseFloat(best.lat),
        lon: parseFloat(best.lon),
        bbox,
        polygon: best.geojson || null,
        display_name: best.display_name || location,
      };
      geocodeCache[location] = coords;
      return coords;
    } else {
      throw new Error("Location not found");
    }
  }

  // Overpass API endpoints with fallback order
  const overpassEndpoints = [
    "https://overpass-api.de/api/interpreter",
    "https://overpass.openstreetmap.fr/api/interpreter",
    "https://overpass.osm.ch/api/interpreter",
    "https://overpass.kumi.systems/api/interpreter",
    "https://overpass.private.coffee/api/interpreter",
  ];

  // Fetch Overpass data via POST with fallback between endpoints
  async function fetchWithFallbackPOST(urls, query) {
    let lastError = null;
    for (let url of urls) {
      try {
        const res = await fetch(url, {
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          body: "data=" + encodeURIComponent(query),
        });
        if (!res.ok) {
          lastError = new Error(`HTTP error ${res.status} at ${url}`);
          continue; // try next endpoint
        }
        const data = await res.json();
        return data; // success
      } catch (err) {
        lastError = err;
      }
    }
    throw lastError || new Error("All Overpass endpoints failed via POST");
  }

  // Build Overpass query with polygon or radius search
  function buildQuery(lat, lon, tagConfigs, polygonGeoJSON) {
    const queryParts = [];

    function buildFilter(cfg) {
      let f = `["${cfg.key}"="${cfg.value}"]`;
      if (cfg.brand) f += `["brand"="${cfg.brand}"]`;
      if (cfg.operator) f += `["operator"="${cfg.operator}"]`;
      if (cfg.additional) f += `[${cfg.additional}]`;
      return f;
    }

    let geomFilter = "";
    if (polygonGeoJSON && polygonGeoJSON.type === "Polygon") {
      const coords = polygonGeoJSON.coordinates[0]
        .map(([lon, lat]) => `${lat} ${lon}`)
        .join(" ");
      geomFilter = `poly:"${coords}"`;
    } else if (polygonGeoJSON && polygonGeoJSON.type === "MultiPolygon") {
      const coords = polygonGeoJSON.coordinates
        .map(
          (poly) =>
            poly[0]
              .map(([lon, lat]) => `${lat} ${lon}`)
              .join(" ")
        )
        .join(" ");
      geomFilter = `poly:"${coords}"`;
    } else {
      geomFilter = `around:10000,${lat},${lon}`; // 10km radius default
    }

    tagConfigs.forEach((cfg) => {
      const filter = buildFilter(cfg);
      queryParts.push(`node${filter}(${geomFilter});`);
      queryParts.push(`way${filter}(${geomFilter});`);
      queryParts.push(`relation${filter}(${geomFilter});`);
    });

    return `[out:json][timeout:120];(${queryParts.join("")});out geom center tags;`;
  }

  async function fetchData() {
    const location = document.getElementById("location").value.trim();
    const category = document.getElementById("category").value;
    const subcategory = document.getElementById("subcategory").value;
    const searchBtn = document.getElementById("searchBtn");

    if (!location || !subcategory) {
      alert("Please enter a location and select a type.");
      return;
    }

    searchBtn.classList.add("loading");
    searchBtn.textContent = "Loading...";

    try {
      const locData = await geocodeLocation(location);
      let { lat, lon, bbox, polygon, display_name } = locData;
      lat = Number(lat);
      lon = Number(lon);

      markerGroup.clearLayers();
      document.getElementById("results").innerHTML = "";

      if (bbox && bbox.length === 4) {
        // bbox = [south, north, west, east]
        const southWest = L.latLng(bbox[0], bbox[2]);
        const northEast = L.latLng(bbox[1], bbox[3]);
        const bounds = L.latLngBounds(southWest, northEast);
        map.fitBounds(bounds);
      } else {
        map.setView([lat, lon], 10);
      }

      if (window.locPolygonLayer) {
        map.removeLayer(window.locPolygonLayer);
      }
      if (polygon) {
        window.locPolygonLayer = L.geoJSON(polygon, {
          style: { color: "blue", weight: 2, fillOpacity: 0.1 },
        }).addTo(map);
      } else {
        if (window.searchCircle) map.removeLayer(window.searchCircle);
        window.searchCircle = L.circle([lat, lon], {
          radius: 10000,
          color: "blue",
          fillOpacity: 0.1,
        }).addTo(map);
      }

      const tagConfigs = categoryOptions[category][subcategory];
      if (!tagConfigs) {
        throw new Error("Invalid category or subcategory selection");
      }

      const query = buildQuery(lat, lon, tagConfigs, polygon);
      const data = await fetchWithFallbackPOST(overpassEndpoints, query);

      results = [];

      const sorted = data.elements
        .map((el) => {
          let elLat, elLon;

          if (el.tags && el.tags.entrance) {
            elLat = el.lat;
            elLon = el.lon;
          } else if (el.lat && el.lon) {
            elLat = el.lat;
            elLon = el.lon;
          } else if (el.center) {
            elLat = el.center.lat;
            elLon = el.center.lon;
          } else if (el.geometry && el.geometry.length > 0) {
            const firstPoint = el.geometry[0];
            elLat = firstPoint.lat;
            elLon = firstPoint.lon;
          }

          const name =
            el.tags.name || el.tags.brand || el.tags.operator || "Unnamed";
          const street = el.tags["addr:street"] || el.tags["addr:housename"] || "";
          const cityAddr = el.tags["addr:city"] || el.tags["addr:town"] || "";
          const postcode = el.tags["addr:postcode"] || "";
          let address = `${street}, ${cityAddr}, ${postcode}`
            .replace(/^, | , ,|, $/g, "")
            .trim();

          return { name, address, lat: elLat, lon: elLon, type: el.type };
        })
        .filter((item) => item.lat && item.lon)
        .sort((a, b) => a.name.localeCompare(b.name));

      sorted.forEach(({ name, address, lat, lon, type }) => {
        const gmapsLink = `https://www.google.com/maps?q=${lat},${lon}`;
        const accuracy = type === "node" ? "📍" : "🏢";
        const marker = L.marker([lat, lon]).bindPopup(
          `<strong>${name}</strong><br>${address}<br><small>Type: ${type} ${accuracy}</small><br><a href='${gmapsLink}' target='_blank'>Google Maps</a>`
        );
        markerGroup.addLayer(marker);
        results.push({ name, address, lat, lon, type });
        const row = `<div><strong>${name}</strong> ${accuracy}<br>${address}<br><a href='${gmapsLink}' target='_blank'>View</a><br><small>${lat.toFixed(
          6
        )}, ${lon.toFixed(6)}</small></div><hr>`;
        document.getElementById("results").innerHTML += row;
      });

      if (results.length > 0) {
        if (window.locPolygonLayer) {
          map.fitBounds(window.locPolygonLayer.getBounds());
        } else {
          map.fitBounds(markerGroup.getBounds());
        }
      } else {
        alert("No results found.");
      }

      document.getElementById("results").insertAdjacentHTML(
        "afterbegin",
        `<div><strong>${results.length} results found for ${subcategory} in ${display_name}.</strong></div><hr>`
      );
    } catch (err) {
      alert("Error: " + err.message);
    } finally {
      searchBtn.classList.remove("loading");
      searchBtn.textContent = "Search";
    }
  }

  function downloadCSV() {
    if (!results.length) return alert("No data to download.");
    let csv = "Name,Address,Latitude,Longitude,Type\n";
    results.forEach((r) => {
      csv += `"${r.name}","${r.address}",${r.lat},${r.lon},${r.type || "unknown"}\n`;
    });
    const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `locations_${new Date().toISOString().split("T")[0]}.csv`;
    a.click();
  }

  function downloadGeoJSON() {
    if (!results.length) return alert("No data to export.");
    const geojson = {
      type: "FeatureCollection",
      features: results.map((r) => ({
        type: "Feature",
        geometry: { type: "Point", coordinates: [r.lon, r.lat] },
        properties: { name: r.name, address: r.address },
      })),
    };
    const blob = new Blob([JSON.stringify(geojson, null, 2)], {
      type: "application/json",
    });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `locations_${new Date().toISOString().split("T")[0]}.geojson`;
    a.click();
  }

  // Initialize subcategories on page load and category change
  suggestTags();
  document.getElementById("category").addEventListener("change", suggestTags);
</script>
</body>
</html>